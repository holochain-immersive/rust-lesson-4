<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <meta name="Description" content="Put your description here." />
    <base href="/" />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background-color: #ededed;
        --r-main-font-size: 24px;
        --r-heading-margin: 20px 0 12px 0;
      }

      .slides {
        width: 75% !important;
      }

      .container {
        top: 0 !important;
        display: flex !important;
        flex-direction: row !important;
      }

      .column {
        flex: 1;
      }

      section {
        text-align: left;
      }

      .popover {
        position: absolute;
        background-color: #4d4d4d;
        padding: 1rem 2rem;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        border-radius: 10px;
        width: auto;
        transform: translate(35px, -15px);
      }

      .popover:after {
        content: "";
        position: absolute;
        top: 6px;
        left: -10px;
        border-style: solid;
        border-width: 25px 25px 0;
        border-color: #4d4d4d transparent;
        display: block;
        width: 0;
        z-index: 1;
        transform: translate(-50%, 50%) rotate(90deg);
      }

      .reveal pre code {
        max-height: 800px !important;
      }
    </style>
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/dist/theme/black.css"
    />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/monokai.css"
    />
    <title>Lesson 4</title>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Generic Types</h1>
        </section>

        <section>
          <h3>Generic Types</h3>

          <li class="fragment fade-in-then-semi-out">
            <em>Definition</em>: A generic is a type defined in relation to one
            or more other types
          </li>
          <li class="fragment fade-in-then-semi-out">
            I pattern of code reuse, like functions or classes, but at a higher
            level of abstraction
          </li>
          <li class="fragment fade-in-then-semi-out">
            Use <code>&lt></code> syntax at instantiation type for specifying
            the related types
          </li>
          <li class="fragment fade-in-then-semi-out">Used in:</li>
          <ul>
            <li class="fragment fade-in-then-semi-out">Stucts and enums</li>
            <li class="fragment fade-in-then-semi-out">Options</li>
            <li class="fragment fade-in-then-semi-out">Generic functions</li>
            <li class="fragment fade-in-then-semi-out">Collections</li>
            <li class="fragment fade-in-then-semi-out">Error handling</li>
            <span class="fragment"></span>
          </ul>
        </section>
        <section>
          <h3>Option</h3>

          <li class="fragment fade-in-then-semi-out">
            Serves the same purpose as <code>null</code> from most other languages
          </li>
          <li class="fragment fade-in-then-semi-out">
            Is an Enum with two variants, <code>None</code> and <code>Some&ltT></code>
          </li>
          <li class="fragment fade-in-then-semi-out">
            When instantiating, you can leave off <code>Option::</code>, because it's so common it was built into the
            language
          </li>
  
          <pre><code class="rust" data-noescape>
  <span class="fragment">
  // Option is an Enum with two variants, None and Some&lt;T&gt;
  </span>
  <span class="fragment">
  // If we were implementing the Option enum from scratch, it might look like:
  </span>
  <span class="fragment">
  Option&lt;T&gt; {
    <span class="fragment">
    // An instance of the Option enum can take one of two forms
    </span>
    <span class="fragment">
    Some(T),<span class="fragment"> // one containing a payload of your specified type</span>
    None<span class="fragment"> // one flagging the absence of a payload</span>
        <span class="fragment"> // Serves the same purpose as null from most other languages</span>
    </span>
  }
  </span>
  
  fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -> Option&lt;i32&gt; {
        match x {
            None => None, // You can leave off "Option::", it's built into the language
            Some(i) => Some(i + 1),
        }
    }
  
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
  }
          </code></pre>
          </section>

        <section>
          <h3>Generic functions</h3>
          <li class="fragment fade-in-then-semi-out">
            With <code>Some&ltT></code> after the function name in the definition
          </li>
          <li class="fragment fade-in-then-semi-out">
            When calling the function, you can specify the return value type either:
          </li>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              After the variable name to which the function's return value is assigned
            </li>
            <li class="fragment fade-in-then-semi-out">
              Between the function name and the parameter list with <code>::&ltT></code>
            </li>
          </ul>
  
          <pre><code class="rust" data-noescape>
fn wrap_into_option&lt;T&gt;(value: T) -> Option&lt;T&gt; { //  With <code>Some&ltT></code> after the function name in the definition
  Option(value)
}

fn main() {
  // When calling the function, you can specify the return value type either:
  let maybe_number: Option&lt;u32&gt; = wrap_into_option(4); // After the variable name to which the function's return value is assigned
  let maybe_number = wrap_into_option::&lt;u32&gt;(4); // Between the function name and the parameter list with <code>::&ltT></code>
        </code></pre>
        </section>

        <section>
          <h3>Collections</h3>

          <h4>Vectors</h4>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Like arrays
            </li>
            <li class="fragment fade-in-then-semi-out">
              <code>vec![]</code> (declarative macro)
            </li>
            <li class="fragment fade-in-then-semi-out">
              Vectors can be grown (dynamic memory allocation)
            </li>
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Less efficient than arrays
              </li>
              <li class="fragment fade-in-then-semi-out">
                Allows for out of bounds indexing
              </li>
            </ul>
            <li class="fragment fade-in-then-semi-out">
              <code>.get</code>
            </li>
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Returns an option
              </li>
            </ul>
            <li class="fragment fade-in-then-semi-out">
              Can be converted to an iterator (coming up next)
            </li>
          </ul>
          
          <pre><code class="rust">
fn main() {
  let empty: Vec&lt;u32&gt; = Vec::new(); // New empty vector
  let mut numbers: Vec&lt;u32&gt; = vec![1, 2, 3]; // New vector with 3 elements

  numbers.push(5); // Vectors can be grown (dynamic memory allocation)

  let first = numbers[0]; // Allows for out of bounds indexing

  let maybe_sixth: Option&lt;u32&gt; = numbers.get(5); // Returns an option, safer

  let summed_numbers: Vec&lt;u32&gt; = numbers.into_iter().map(|x| x + 1).collect(); // Can be converted into iterators
}
        </code></pre>
        </section>

        <section>
          <h3>Collections</h3>

          <h4>Hashmaps</h4>
          <li class="fragment fade-in-then-semi-out">
            Hashmaps
          </li>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Methods are <code>.insert()</code>, <code>.get()</code>, and <code>.remove()</code>
            </li>
            <li class="fragment fade-in-then-semi-out">
              <code>.iter()</code> provides an iterator over the key-value pairs
            </li>
            <li class="fragment fade-in-then-semi-out">
              in addition to <code>iter()</code>, there are <code>.keys()</code> and <code>.values()</code>
            </li>
          </ul>
          <pre><code class="rust">
use std::collections::Hashmap;

fn main() {
  let mut ages: HashMap&lt;String, u32&gt; = HashMap::new(); // New empty HashMap
  
  let alice_name = String::from("Alice");
  ages.insert(alice_name, 53); // Inserting with key and value, requires mutability

  let alice_age: Option&lt;u32&gt; = ages.get(alice_name); // Getting an option by key
 
  ages.remove(alice_name); // Removes the given key, requires mutability

  for (name, age) in ages.iter() { // Iterate over the (key, value) pairs
    println!("{} is {} years old", name, age);
  }
  for name in ages.keys() { /* Iterate over keys */ }
  for age in ages.values() { /* Iterate over values */ }
}
</code></pre>
        </section>
        <section>
          <h3>Error Handling</h3>

          <li class="fragment fade-in-then-semi-out">Panic</li>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Crashes the application immediately
            </li>
            <li class="fragment fade-in-then-semi-out">
              Out-of-bounds error is one thing that leads to this
            </li>
          </ul>

          <li class="fragment fade-in-then-semi-out">
            The <code>Result</code> enum
          </li>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              A generic result over two types
            </li>
            <ul>
              <li class="fragment fade-in-then-semi-out">
                The <code>Ok</code> type for when all goes right
              </li>
              <li class="fragment fade-in-then-semi-out">
                The the <code>Err</code> type for when there is an error
              </li>
            </ul>
            <li class="fragment fade-in-then-semi-out">
              It's common when writing error handling for an outer function to:
            </li>
            <ul>
              <li class="fragment fade-in-then-semi-out">
                <code>match</code> against the variant of the <code>Result</code> instance (<code>Error</code> or
                <code>Ok</code>)
              </li>
              <li class="fragment fade-in-then-semi-out">
                Pass along any errors as its return value if the subroutine failed
              </li>
              <li class="fragment fade-in-then-semi-out">
                Define the primary code to be run conditionally in the <code>Ok</code> arm.
              </li>
              <ul>
                <li class="fragment fade-in-then-semi-out">
                  This can all be done with a <code>?</code> after the function invocation
                </li>
                <ul>
                  <li class="fragment fade-in-then-semi-out">
                    Injects the error matching and passalong code
                  </li>
                </ul>
              </ul>
            </ul>
          </ul>
          <li class="fragment fade-in-then-semi-out">
            <code>unwrap</code>
          </li>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Used on a <code>Result</code> or <code>Option</code>
            </li>
            <li class="fragment fade-in-then-semi-out">
              Panics on <code>Err</code> or <code>None</code>
            </li>
            <li class="fragment fade-in-then-semi-out">
              Very bad practice
            </li>
          </ul>
          <pre><code class="rust" data-noescape>
enum Result&lt;T, E&gt; { // Generic result over two types
  Ok(T), // The <code>Ok</code> type for when all goes right
  Err(E) // The <code>Err</code> type for when there is an error
}
        </code></pre>
        </section>

        <section>
          <h3>Error Handling</h3>

          <pre><code class="rust" data-noescape>
fn simple_computation() -> Result&lt;u32, String&gt; {
  // ...
}

fn complex_computation() -> Result&lt;u32, String&gt; {
  let result = simple_computation();

  match result { // This pattern is really common
    Ok(number) => {
      // Define primary code

      Ok(number)
    },
    Err(err) => Err(err) // match and return if there is an error
  }
}

fn complex_computation() -> Result&lt;u32, String&gt; {
  let result = simple_computation()?; // If result is Err, return that to the caller function and stop function execution

  let result = simple_computation().unwrap(); // If result is Err, panic: very bad practice
  let result = Option::Some(4).unwrap(); // If result is None, panic
}
</code></pre>
        </section>

        <!-- potential error handling example -->
        <!-- <section>
        <pre><code class="rust" data-noescape>
          fn main() {
              panic!("crash and burn");
          }
        </code></pre>
        <pre><code class="rust" data-noescape>
          enum Result&ltT, E> {
              Ok(T),
              Err(E),
          }
        </code></pre>
        <pre><code class="rust" data-noescape>
          fn main() {
              let f = File::open("hello.txt");

              let f = match f {
                  Ok(file) => file,
                  Err(error) => panic!("Problem opening the file: {:?}", error),
              };
          }
        </code></pre>
        <pre><code class="rust" data-noescape>
          fn read_username_from_file() -> Result<String, io::Error> {
              let mut f = File::open("hello.txt")?;
              let mut s = String::new();
              f.read_to_string(&mut s)?;
              Ok(s)
          }
        </code></pre>
        <pre><code class="rust" data-noescape>
          fn main() {
              let f = File::open("hello.txt").unwrap();
          }
        </code></pre>
      </section> -->
        <section>
          <h1>That's it!</h1>
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "reveal.js";
      import Markdown from "reveal.js/plugin/markdown/markdown.esm.js";
      import RevealHighlight from "reveal.js/plugin/highlight/highlight.esm.js";
      import RevealNotes from "reveal.js/plugin/notes/notes.esm.js";
      import RevealNestedFragments from "reveal.js-nested-fragments";
      import RevealEliminateEmtpyLines from "reveal.js-eliminate-empty-lines";
      import RevealAnimateFragments from "reveal.js-animate-fragments";

      let deck = new Reveal({
        transition: "none",
        plugins: [
          Markdown,
          RevealHighlight,
          RevealNotes,
          RevealNestedFragments,
          RevealEliminateEmtpyLines,
          RevealAnimateFragments
        ],
      });
      deck.initialize();
    </script>
  </body>
</html>
